# -*- coding: utf-8 -*-
"""app.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/14E3cFdr_FoHYVJWn1l1INa26VpZ-_m0D
"""


# =========================
# 2. Streamlit Web App
# =========================

# Save this as app.py

# Install required packages (do this in Colab or local)
# !pip install torch torchvision streamlit

# =========================
# 1. Train a simple GAN model for MNIST digits
# =========================

import torch
import torch.nn as nn
import torch.optim as optim
from torchvision import datasets, transforms
from torch.utils.data import DataLoader

# Generator model
class Generator(nn.Module):
    def __init__(self, z_dim=100, img_dim=28*28):
        super(Generator, self).__init__()
        self.gen = nn.Sequential(
            nn.Linear(z_dim + 10, 128),
            nn.ReLU(),
            nn.Linear(128, 256),
            nn.ReLU(),
            nn.Linear(256, img_dim),
            nn.Tanh()
        )

    def forward(self, noise, labels):
        x = torch.cat([noise, labels], dim=1)
        return self.gen(x)

# Simple discriminator (optional, but for training completeness)
class Discriminator(nn.Module):
    def __init__(self, img_dim=28*28):
        super(Discriminator, self).__init__()
        self.disc = nn.Sequential(
            nn.Linear(img_dim + 10, 256),
            nn.LeakyReLU(0.2),
            nn.Linear(256, 128),
            nn.LeakyReLU(0.2),
            nn.Linear(128, 1),
            nn.Sigmoid()
        )

    def forward(self, img, labels):
        x = torch.cat([img, labels], dim=1)
        return self.disc(x)

# Hyperparameters
z_dim = 100
lr = 0.0002
epochs = 5
batch_size = 64

# Data
transform = transforms.Compose([
    transforms.ToTensor(),
    transforms.Normalize((0.5,), (0.5,))
])
train_data = datasets.MNIST(root="./data", train=True, transform=transform, download=True)
loader = DataLoader(train_data, batch_size=batch_size, shuffle=True)

# Initialize models
gen = Generator(z_dim)
disc = Discriminator()

criterion = nn.BCELoss()
gen_opt = optim.Adam(gen.parameters(), lr=lr)
disc_opt = optim.Adam(disc.parameters(), lr=lr)

# Training loop (simplified)
for epoch in range(epochs):
    for real, labels in loader:
        real = real.view(-1, 28*28)
        batch_size = real.size(0)

        # One-hot encode labels
        labels_onehot = torch.nn.functional.one_hot(labels, num_classes=10).float()

        # Train discriminator
        noise = torch.randn(batch_size, z_dim)
        fake_labels = torch.randint(0, 10, (batch_size,))
        fake_labels_onehot = torch.nn.functional.one_hot(fake_labels, num_classes=10).float()
        fake = gen(noise, fake_labels_onehot)

        disc_real = disc(real, labels_onehot).view(-1)
        disc_fake = disc(fake.detach(), fake_labels_onehot).view(-1)

        loss_disc = criterion(disc_real, torch.ones_like(disc_real)) + \
                    criterion(disc_fake, torch.zeros_like(disc_fake))

        disc.zero_grad()
        loss_disc.backward()
        disc_opt.step()

        # Train generator
        output = disc(fake, fake_labels_onehot).view(-1)
        loss_gen = criterion(output, torch.ones_like(output))

        gen.zero_grad()
        loss_gen.backward()
        gen_opt.step()

    print(f"Epoch [{epoch+1}/{epochs}]  Loss D: {loss_disc:.4f}, Loss G: {loss_gen:.4f}")

# Save the trained generator
torch.save(gen.state_dict(), "generator.pt")

import streamlit as st
import matplotlib.pyplot as plt

def load_generator():
    model = Generator()
    model.load_state_dict(torch.load("generator.pt", map_location=torch.device('cpu')))
    model.eval()
    return model

def generate_images(generator, digit, num_samples=5):
    noise = torch.randn(num_samples, z_dim)
    labels = torch.full((num_samples,), digit, dtype=torch.long)
    labels_onehot = torch.nn.functional.one_hot(labels, num_classes=10).float()
    with torch.no_grad():
        fake_images = generator(noise, labels_onehot).view(-1, 28, 28)
    return fake_images

st.title("Handwritten Digit Image Generator")

digit = st.selectbox("Select a digit to generate:", list(range(10)))

if st.button("Generate Images"):
    generator = load_generator()
    images = generate_images(generator, digit)
    fig, axes = plt.subplots(1, 5, figsize=(15, 3))
    for img, ax in zip(images, axes):
        ax.imshow(img.squeeze(), cmap="gray")
        ax.axis("off")
    st.pyplot(fig)

